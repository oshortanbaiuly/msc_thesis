# -*- coding: utf-8 -*-
"""appendix_c.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aBO5QcPcOZdVMcIgXEW9MVaDVzRYjuUw
"""

import numpy as np
import time
import random
import matplotlib.pyplot as plt

# returns costs array for the given curent states and action
# real valued
def cost(state, action):
  cost = (state ** 2) + (action ** 2)
  cost = np.round(cost, 2)

  return cost

# real valued scalar
def random_next_element(state, action, ran):
  next_state = round(state + action + ran, 2)

  return next_state

def V_hash(V_table, time, state, value):
  key = (time, state)
  V_table[key] = value

  return V_table

def V_lookup(V_table, time, state):
  key = (time, state)
  value = V_table[key]

  return value

def init_cost(state, time):
  max_action = 2
  max_random = 2
  terminal = 5
  val = state**2 + max_action**2
  for i in range(0, terminal - time + 1):
    next_state = state + max_random + max_action
    tmp = next_state**2 + max_action**2
    val+= tmp

  return val

# dynamic avar calculation
# at each time t; calculates avar using the next time's avar value as the r.v.
def avar(V_table, alpha, state, s, action, time, terminal, ran_arr):
  # if terminal calculate the terminal value AND hash the value for that c(state,...)+ aggr - s for that (state, aggr)

  if time == terminal:
    avar_val = np.round(cost(state, action),2)

    return (avar_val, V_table)
  #otherwise calculate next stage and next aval avar
  else:
    ran_len = len(ran_arr)
    next_time = time + 1
    s_arr = np.array([])
    tmp = 0
    avar_val = 0
    for ran in ran_arr:
    #find the avar for the next space for the given fixed action
      next_state = random_next_element(state, action, ran)  # F(x_t, a_t, \xi_t) # real valued
      next_time = time + 1
      next_key = (next_time, next_state)
      val_2 = 0
      if next_key in V_table: # in V_table_val
        print('KEY {} found next_time: {}, next_state: {} with used action: {}'.format(next_key, next_time, next_state, action))
        val_2 = V_lookup(V_table, next_time, next_state) #V lookup val without act
        print('val_2 by looking up: ', val_2)
      else:
        print('KEY {} NOT found next_time: {}, next_state: {} with used action: {}'.format(next_key, next_time, next_state, action))
        val_2 = init_cost(state, time)
        print('init cost val2: ', val_2)
        #hash that void value to the corresponding key
        V_table = V_hash( V_table, next_time, next_state, val_2) # V hash val without act
      s_arr = np.append(s_arr, val_2)
    s_q = np.quantile(s_arr, alpha, interpolation='linear')  # real valued quantile for s_q
    s_q = np.round(s_q, 2)
    for elt in s_arr:
      avar_val += (1 / ran_len) * max(elt - s_q, 0) # expected value part
    avar_val = s_q + (1 / (1 - alpha)) * avar_val #the remaining arithmetic operations
    avar_val = cost(state, action) + avar_val # accumulating the cost
    avar_val = np.round(avar_val,2)

    print('time, state, action: ', time, state,  action)

    return (avar_val, V_table)

# dynamic avar calculation
# at each time t; calculates avar using the next time's avar value as the r.v.
def avar(V_table, alpha, state, s, action, time, terminal, ran_arr):
  # if terminal calculate the terminal value AND hash the value for that c(state,...)+ aggr - s for that (state, aggr)

  if time == terminal:
    avar_val = np.round(cost(state, action),2)

    return (avar_val, V_table)
  #otherwise calculate next stage and next aval avar
  else:
    ran_len = len(ran_arr)
    next_time = time + 1
    s_arr = np.array([])
    tmp = 0
    avar_val = 0
    for ran in ran_arr:
    #find the avar for the next space for the given fixed action
      next_state = random_next_element(state, action, ran)  # F(x_t, a_t, \xi_t) # real valued
      next_time = time + 1
      next_key = (next_time, next_state)
      val_2 = 0
      if next_key in V_table: # in V_table_val
        print('KEY {} found next_time: {}, next_state: {} with used action: {}'.format(next_key, next_time, next_state, action))
        val_2 = V_lookup(V_table, next_time, next_state) #V lookup val without act
        print('val_2 by looking up: ', val_2)
      else:
        print('KEY {} NOT found next_time: {}, next_state: {} with used action: {}'.format(next_key, next_time, next_state, action))
        val_2 = init_cost(state, time)
        print('init cost val2: ', val_2)
        #hash that void value to the corresponding key
        V_table = V_hash( V_table, next_time, next_state, val_2) # V hash val without act
      s_arr = np.append(s_arr, val_2)
    s_q = np.quantile(s_arr, alpha, interpolation='linear')  # real valued quantile for s_q
    s_q = np.round(s_q, 2)
    for elt in s_arr:
      avar_val += (1 / ran_len) * max(elt - s_q, 0) # expected value part
    avar_val = s_q + (1 / (1 - alpha)) * avar_val #the remaining arithmetic operations
    avar_val = cost(state, action) + avar_val # accumulating the cost
    avar_val = np.round(avar_val,2)

    print('time, state, action: ', time, state,  action)

    return (avar_val, V_table)

#running the simulations
def simulate(x_0, t_0, T, alpha, action_arr, random_arr, N, s, lr):

  print('s in simulate: ', s)

  V_table = Running_Bellman(alpha, T, action_arr, random_arr, N, s, x_0, lr)

  return  V_table


# Simulation with Bernoulli noise

x_0 = 1 # initial state
t_0 = 0 # initial time
T = 2 # terminal time
N = 200 # maximum number of iterations
alpha = 0.00 # risk level, can be 0, 0.25, 0.5, 0.75, 0.99

s_array = np.array([0]) # s to be minimized in AVaR formula
action_arr = np.array([-1, -0.5, 0, 0.5, 1]) # initial set of actions
random_arr = np.array([-1, 1]) # array of random Bernoulli noises

key = (t_0, x_0) # initial key
min_value = float('inf')
V_min = {}

for r_a in s_array:
  V_table = simulate(x_0, t_0, T, alpha, action_arr, random_arr, N, r_a, lr = 0.95)
  tmp = V_table[key]
  if tmp < min_value:
    #if the initial value is minimum then assign the value function as the minimum
    V_min = V_table
    min_value = tmp
    s_min = r_a

print('(V_min[(time,state, aggr)]: min_value)', V_min)
print('s_min: ', s_min)
print('V_min[({}, {})]: {}'.format(t_0, x_0, min_value))


# Simulation with Exponential noise

x_0 = 1 # initial state
t_0 = 0 # initial time
T = 2 # terminal time
N = 200 # maximum number of iterations
alpha = 0.00 # risk level, can be 0, 0.25, 0.5, 0.75, 0.99

s_array = np.array([0])
action_arr = np.array([-1, 0, 1]) # initial set of actions

np.random.seed(41) # setting the seed for reproducibility
random_arr = np.random.exponential(scale = 1.0, size = 6) # sample 6 points from exponential distribution with lambda = 1
random_arr = np.array(sorted(np.round(random_arr, 2)))

key = (t_0, x_0) # initial key
min_value = float('inf')
V_min = {}

for r_a in s_array:
  V_table = simulate(x_0, t_0, T, alpha, action_arr, random_arr, N, r_a, lr = 0.99)
  tmp = V_table[key]
  if tmp < min_value:
    #if the initial value is minimum then assign the value function as the minimum
    V_min = V_table
    min_value = tmp
    s_min = r_a

print('(V_min[(time,state, aggr)]: min_value)', V_min)
print('s_min: ', s_min)
print('V_min[({}, {})]: {}'.format(t_0, x_0, min_value))

