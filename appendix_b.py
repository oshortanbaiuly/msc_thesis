# -*- coding: utf-8 -*-
"""appendix_b.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DHP-n8NW4sovcnOQlamROpBDlIu_bL6R
"""

import numpy as np

alpha = 0.25 #setting risk level

action_arr = np.array([-1, 0, 1]) # initial set of actions

np.random.seed(41) # setting the seed for reproducibility
random_arr = np.random.exponential(scale = 1.0, size = 6) # sample 6 points from exponential distribution with lambda = 1
random_arr = np.array(sorted(np.round(random_arr, 2)))

x1_vals = [] # array to store x1 values

for a in action_arr:
  for w in random_arr:
    x1_vals.append(round(1 + a + w, 2)) # #iterating through all possible actions and noises

# computing q-quantile given x1, a and random noise values for 0 <= q < = 1
def quantile_finder(x1, a, random_arr, q):
  lst = []
  for ran in random_arr:
    lst.append((x1 + a + ran)**2)
  qt = np.quantile(lst, q) # Numpy function for quantile
  return qt

# solving for optimal j(1, x1) for each x1
def j1_finder (x1_vals, a_vals, random_arr):
  j_vals = [] # array to store j1 values
  for x1 in x1_vals:
    q_vals = [] # array to store qt values

    for a in action_arr:
      # get a quantile for each x1 and a pair
      qt = np.round(quantile_finder(x1, a, random_arr, q = alpha), 2)

      sum = 0
      # replacing the expected value by average sum through all random noises
      for ran in random_arr:
          sum += (1/6)*max((x1 + a + ran)**2 - qt, 0)

      # computing the value function
      q = np.round(x1**2 + a**2 + qt + sum*2, 2)
      print('x1: {}, a: {}, qt: {}, q: {}'.format(x1, a, qt, q))
      q_vals.append(q)

    # getting the minimum value J(1, x1) for each x1
    j1 = np.min(q_vals)
    j_vals.append(j1)

  return j_vals

# function call to get an array of j1 values for all possible x1 values
j1 = j1_finder(x1_vals, action_arr, random_arr)


def j0_finder (j1):
  j0_vals = [] # array to store j0 values
  a = -1
  for i in range(3):
    # compute quantile for each action
    qt = np.round(np.quantile(j1[6*i:6*i+6], q = alpha), 2)

    sum = 0
    # replacing the expected value by average sum through all random noises
    for j in range(6*i, 6*i + 6):
      sum += (1/6)*max(j1[j] - qt, 0)

    # computing the value function
    q = np.round(1 + a**2 + qt + sum*2, 2)
    print('a: {}, qt: {}, q: {}'.format(a, qt, q))

    # getting the J(0, x0, a0) for each a0
    j0_vals.append(q)
    a += 1

  # getting the minimum value J(0, x0) for each x0
  j0 = np.min(j0_vals)
  return j0

# function call to get an array of j0 values for all possible x0 values
j0 = j0_finder(j1)

